# Розвідувальний аналіз даних

## Імпорт бібліотек

```{python}
import pandas as pd
import numpy as np
import datetime
import pyarrow.parquet as pq


import matplotlib.pyplot as plt
import ptitprince as pt
import seaborn as sns
import joypy
import plotly.express as px
import plotly.graph_objects as go
from scipy.interpolate import griddata
from plotnine import *

from sklearn.model_selection import train_test_split

import warnings
warnings.filterwarnings("ignore")
```

## Вхідні дані

У роботі використаний набір даних, отриманий за допомогою парсингу маркетплейсу Autoria за 10 вересня 2022 року: <https://auto.ria.com/uk>. Даний сайт працює як віртуальний торговельний майданчик із загальнодоступними оголошеннями про продаж автомобілів разом з інформацією про їх характеристики.

Опис змінних:

1. `price` – ціна автомобіля (дол.);
1. `full_name` – повна назва автомобіля (включає в себе марку та модель);
1. `brand` – марка автомобіля;
1. `model` – модель автомобіля;
1. `make_year` – рік випуску автомобіля;
1. `mileage` – пробіг автомобіля (тис. км.);
1. `location` – фізичне місце розташування автомобіля (включає в себе міста, села, поселення міського типу);
1. `region` - регіон розташування автомобіля;
1. `fuel` – тип палива автомобіля;
1. `disp` – об‘єм двигуна автомобіля (л.);
1. `gearbox` – тип коробки передач автомобіля;
1. `drive` – тип приводу автомобіля;
1. `accident` – ДТП (потрапляв автомобіль в ДТП чи ні);
1. `vin` – VIN-code (перевірений VIN-code чи ні);
1. `desc` – опис оголошення.

```{python}
#| column: screen-inset-shaded
#| tbl-cap: 'Вхідні дані'
df = pd.read_csv('00_data/cars.csv')
df.head()
```

## Первинний аналіз даних
Загальна інформація про датасет
```{python}
df.info()
```

Опис числових змінних
```{python}
df.describe()
```

Кількість пропущених значень
```{python}
df.isna().sum()
```

Кількість автомобілів за типом палива
```{python}
df.fuel.value_counts()
```

Кількість представлених брендів
```{python}
df["brand"].nunique()
```

Найпопулярніші бренди
```{python}
df['brand'].value_counts().head()
```

## Візуалізація даних

### Топ популярних та непопулярних брендів
```{python}
#| column: screen-inset-shaded
#| layout-nrow: 1

df_counts = df["brand"].value_counts().iloc[:25].reset_index()
df_counts.columns = ["brand", "count"]

fig = px.bar(df_counts, y="brand", x="count", orientation="h")
fig.update_layout(yaxis={'categoryorder':'total ascending'})

fig.update_layout(xaxis_title="Кількість", yaxis_title="", plot_bgcolor='rgba(0,0,0,0)')
fig.show()

df_counts = df["brand"].value_counts().iloc[:-50:-1].reset_index()
df_counts.columns = ["brand", "count"]

fig = px.bar(df_counts, y="brand", x="count", orientation="h")
fig.update_layout(yaxis={'categoryorder':'total descending'})

fig.update_layout(xaxis_title="Кількість", yaxis_title="", plot_bgcolor='rgba(0,0,0,0)')
fig.show()
```

### Топ-5 популярних моделей для популярних брендів

Створемо функцію знаходження топ-5 популярних моделей для популярних брендів.
```{python}
def get_top_models(df, brand, top_n=5):
    # Відфільтровуємо за брендом
    df_brand = df[df["brand"] == brand]
    
    # Згрупуємо за моделлю та порахуємо кількість
    model_counts = df_brand.groupby(by=["model"]).size().reset_index(name="count")

    # Відсортуємо та обмежимо результат до top_n найпопулярніших моделей
    top_models = model_counts.nlargest(top_n, "count")
    
    return top_models
```

Фільтрація даних за брендом та знаходження топ-5 популярних моделей для популярних брендів.
```{python}
top5_vw_models = get_top_models(df, "VOLKSWAGEN")
top5_bmw_models = get_top_models(df, "BMW")
top5_mers_models = get_top_models(df, "MERCEDES-BENZ")
```

```{python}
#| layout-ncol: 3
#| column: page
volk = sns.catplot(y='model', x='count', data=top5_vw_models, kind='bar',
palette='rocket', alpha=0.5, legend=False)
volk.set(xlabel='Кількість', ylabel='Модель автомобіля', title='Volkswagen')
volk.fig.suptitle("")

bmw = sns.catplot(y='model', x='count', data=top5_bmw_models, kind='bar',
palette='rocket', alpha=0.5, legend=False)
bmw.set(xlabel='Кількість', ylabel='Модель автомобіля', title='BMW')
bmw.fig.suptitle("")

mb = sns.catplot(y='model', x='count', data=top5_mers_models, kind='bar',
palette='rocket', alpha=0.5, legend=False)
mb.set(xlabel='Кількість', ylabel='Модель автомобіля', title='Mercedes-Benz')
mb.fig.suptitle("")
plt.show()
```

### Heatmap регіонів України за відсоток представлених автомобілів

Сформуємо таблицю з регіонами України.
```{python}
uaRegionsGrid = pd.DataFrame({
'row': [1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5],
'col': [2, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 2, 5, 6, 7, 4, 6, 5],
'code': list(range(1, 28)),
'name': ["ВОЛИНСЬКА", "КИЇВ", "ЧЕРНІГІВСЬКА", "СУМСЬКА", "ЛЬВІВСЬКА", "ТЕРНОПІЛЬСЬКА", "РІВНЕНСЬКА", "ЖИТОМИРСЬКА", "КИЇВСЬКА", "ПОЛТАВСЬКА", "ХАРКІВСЬКА", "ЛУГАНСЬКА", "ЗАКАРПАТСЬКА", "ІВАНО-ФРАНКІВСЬКА", "ХМЕЛЬНИЦЬКА", "ВІННИЦЬКА", "ЧЕРКАСЬКА", "КІРОВОГРАДСЬКА", "ДНІПРОПЕТРОВСЬКА", "ДОНЕЦЬКА", "ЧЕРНІВЕЦЬКА", "МИКОЛАЇВСЬКА", "ХЕРСОНСЬКА", "ЗАПОРІЗЬКА", "ОДЕСЬКА", "АР КРИМ", "СЕВАСТОПОЛЬ"]
})

data_region_quantity = df.groupby('region').size().reset_index(name='count')
data_region_quantity['percent'] = (data_region_quantity['count'] / data_region_quantity['count'].sum()) * 100
uaCarsQuantity = uaRegionsGrid.merge(data_region_quantity, left_on='name', right_on='region', how='left')
```

Візуалізація heatmap регіонів України за відсоток представлених автомобілів.
```{python}
#| fig-cap: "Відсоток представлених автомобілів в регіонах України"
data = np.asarray(uaCarsQuantity.pivot("row", "col", "percent"))
text = np.asarray(uaCarsQuantity.pivot("row", "col", "region"))
labels = (np.asarray(["{0}\n{1:.2f}".format(text,data) for text, data in zip(text.flatten(), data.flatten())])).reshape(5,8)

sns.set_theme(style='white', font_scale=0.6)
f, ax = plt.subplots(figsize=(9, 6))
sns.heatmap(data,
    annot=labels,
    linewidths=.5,
    fmt='',
    ax=ax,
    cmap=sns.color_palette("BuPu"),
    yticklabels=False,
    xticklabels=False,
    cbar=False)
plt.show()
```

### Розподіл цін на автомобілі в залежності від типу коробки передач
```{python}
f, ax = plt.subplots(figsize=(8, 6))
ax=pt.RainCloud(x = df.gearbox, y = df.price_log, data = df, bw =  0.2, width_viol = 0.9,
                ax = ax, orient = "h" , linewidth=0.1,
                cut = 0,   
                alpha = .65, dodge = True,
                pointplot = True, move = .2)
ax.set_ylabel('')
plt.show()
```

### Розподіл пробігу автомобіля в залежності від типу коробки передач
```{python}
f, ax = plt.subplots(figsize=(8, 6))
ax=pt.RainCloud(x = df.gearbox, y = np.log1p(df.mileage),
                bw = 0.2, width_viol = 0.9,
                ax = ax, orient = "h" , linewidth=0.1,
                alpha = .65, dodge = True,
                pointplot = True, move = .2)
ax.set_ylabel('')
plt.show()
```

### Гребнева візуалізація розподілу цін та пробігу в залежності від віку автомобіля
```{python}
#| layout-ncol: 2
#| column: page
labels=[y if y%5==0 else None for y in list(df.age.unique())]
fig, axes = joypy.joyplot(df, by="age", column="price_log",
                            labels=labels, range_style='own', 
                            grid="y", linewidth=1, legend=False, fade=True,
                            title="Вартість автомобілів по рокам\n(log(Price))",                            
                            kind="counts", bins=50)

labels=[y if y%5==0 else None for y in list(df.age.unique())]
fig, axes = joypy.joyplot(df, by="age", column='mileage',
                            labels=labels, range_style='own', 
                            grid="y", linewidth=1, legend=False, fade=True,
                            title="Пробіг автомобілів по рокам\n(log(Price))",                            
                            kind="counts")

plt.show()
```

### Точкова діаграма цін на автомобілі в залежності року випуску, пробігу та типу коробки передач
```{python}
sns.scatterplot(x="make_year", y="price_log",
                hue="gearbox", data=df,
                size='mileage', alpha=0.5)
plt.show()
```

### 3D візуалізація залежності ціни автомобіля від року випуску та пробігу
```{python}
x = np.array(df.make_year)
y = np.array(df.mileage)
z = np.array(np.log(df.price))


xi = np.linspace(x.min(), x.max(), 100)
yi = np.linspace(y.min(), y.max(), 100)

X,Y = np.meshgrid(xi,yi)

Z = griddata((x,y),z,(X,Y), method='cubic')

fig = go.Figure(go.Surface(x=xi,y=yi,z=Z))
fig.update_layout(scene=dict(
                    xaxis_title='Рік виробництва',
                    yaxis_title='Пробіг',
                    zaxis_title='Ціна',
    ))
fig.show()
```

### Кореляційна матриця
```{python}
corr_matrix = df.corr()

mask = np.zeros_like(corr_matrix, dtype=np.bool)
mask[np.triu_indices_from(mask)]= True

f, ax = plt.subplots(figsize=(8, 6))

heatmap = sns.heatmap(corr_matrix,
                      mask = mask,
                      square = True,
                      linewidths = .5,
                      cmap = 'coolwarm',
                      cbar_kws = {'shrink': .4,
                                  'ticks' : [-1, -.5, 0, 0.5, 1]},
                      vmin = -1,
                      vmax = 1,
                      annot = True,
                      annot_kws = {'size': 12})

ax.set_yticklabels(corr_matrix.columns, rotation = 0)
ax.set_xticklabels(corr_matrix.columns)

sns.set_style({'xtick.bottom': True}, {'ytick.left': True})
```

### Спліт даних на тренувальні та тестові для подальшої роботи
```{python}
train, test = train_test_split(df, test_size=0.2, random_state=2023, shuffle=True)
train.to_csv('00_data_clean/train.csv', index=False)
test.to_csv('00_data_clean/test.csv', index=False)
```